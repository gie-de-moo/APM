setwd('caret_r_forge/')
str(iris)
library(caret)
library(AppliedPredictiveModeling)
install.packages('AppliedPredictiveModeling')
library(AppliedPredictiveModeling)
transparentTheme(trans = .4)
str(iris)
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'pairs')
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'pairs',
# add legends at the top
auto.key = list(columns = 3))
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'ellipse',
auto.key = list(columns = 3))
transparentTheme(trans = .9)
# overlayed density plots
transparentTheme(trans = .9)
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'density',
# pass in options to xyplot() to
# make it prettier
scales = list(x = list(relation='free'),
y = list(relation='free')),
adjust = 1.5,
pch = '|',
layout = c(4,1),
auto.key = list(columns = 3))
# overlayed density plots
transparentTheme(trans = .9)
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'density',
# pass in options to xyplot() to
# make it prettier
scales = list(x = list(relation='free'),
y = list(relation='free')),
adjust = 1.5,
# pch = '|',
layout = c(4,1),
auto.key = list(columns = 3))
# overlayed density plots
transparentTheme(trans = .9)
featurePlot(x = iris[,1:4],
y = iris$Species,
plot = 'density',
# pass in options to xyplot() to
# make it prettier
scales = list(x = list(relation='free'),
y = list(relation='free')),
adjust = 1.5,
pch = '|',
layout = c(4,1),
auto.key = list(columns = 3))
featurePlot(x = iris[, 1:4],
y = iris$Species,
plot = 'box',
## pass in options to bwplot()
scales = list(y = list(relation='free'),
x = list(rot = 90)),
layout = c(4,1),
auto.key = list(columns = 2))
featurePlot(x = iris[, 1:4],
y = iris$Species,
plot = 'box')
featurePlot(x = iris[, 1:4],
y = iris$Species,
plot = 'box',
## pass in options to bwplot()
scales = list(y = list(relation='free'),
x = list(rot = 90)),
layout = c(4,1),
auto.key = list(columns = 2))
library(mlbench)
data(BostonHousing)
str(BostonHousing)
regVar = c('age','lstat','tax')
str(BostonHousing[,regVar])
theme1 = trellis.par.get()
theme1$plot.symbol$col = rgb(.2,.2,.2,.4)
names(theme1$plot.symbol)
theme1$plot.symbol$lwd = 2
theme1 = trellis.par.get()
theme1$plot.symbol$col = rgb(.2,.2,.2,.4)
theme1$plot.symbol$lwd = 2
theme1$plot.line$col = rgb(1,0,0,.7)
theme1$plot.line$lwd = 2
trellis.par.set(theme1)
theme1 = trellis.par.get()
theme1$plot.symbol$col = rgb(.2,.2,.2,.4)
theme1$plot.symbol$lwd = 2
theme1$plot.line$col = rgb(1,0,0,.7)
theme1$plot.line$lwd = 2
trellis.par.set(theme1)
featurePlot(x = BostonHousing[, regVar],
y = BostonHousing$medv,
plot = 'scatter',
layout = c(3,1))
featurePlot(x = BostonHousing[, regVar],
y = BostonHousing$medv,
plot = 'scatter',
# add smoother
type = c('p', 'smooth'),
span = 0.5,
layout = c(3,1))
library(earth)
data(etitanic)
head(etitanic)
head(model.matrix(survived ~., data = etitanic))
?model.matrix
dummies = dummyVars(survived ~ ., data = etitanic)
head(dummies)
str(etitanic)
head(predict(dummies), newdata = etitanic)
head(predict(dummies, newdata = etitanic))
ddta(mdrr)
install.packages('QSARdata')
?quote
install_load <- function(x) {
install.packages(x)
library(x)
}
install_load('QSARdata')
library(as.name('QSARdata'))
library(quote('QSARdata'))
library(a'QSARdata')
library('QSARdata')
install_load('SMCRM')
library('dplyr')
x = 'dplyr'
library(x)
library(as.character(x))
?library
install_load <- function(x) {
install.packages(x)
library(x, character.only = T)
}
library(smcrm)
library(SMCRM)
ddta(mdrr)
data(mdrr)
data.frame(table(mdrrDescr$nR11))
str(mdrrDescr)
table(mdrrDescr$nR11)
data.frame(table(mdrrDescr$nR11))
nzv = nearZeroVar(mdrrDescr, saveMetrics = T)
names(nzv)
class(nzv)
head(nzv)
nzv[nzv$nzv,]{1:10}
nzv[nzv$nzv,][1:10]
nzv[nzv$nzv,][1:10]
nzv[nzv$nzv,][1:10]
head(nzv)
nzv[nzv$nzv,][1:10]
nzv[nzv$nzv,]
nzv[nzv$nzv,][1:10,]
dim(mdrrDescr)
nzv = nearZeroVar(mdrrDescr)
nzv
filteredDescr = mdrrDescr[,-nzv]
dim(filteredDescr)
descrCor = cor(filteredDescr)
descrCor
highCorr = sum(abs(descrCor[upper.tri(descrCor)])>0.999)
highCorr
dim(filteredDescr)
65 / (297*296)
percHighCor = highCorr/(ncol(filteredDescr) ^ 2 - ncol(filteredDescr))
percHighCor
summarise(descrCor[upper.tri(descrCor)])
summary(descrCor[upper.tri(descrCor)])
highlyCorDescr = findCorrelation(descrCor, cutoff = 0.75)
filteredDescr = filteredDescr[, -highlyCorDescr]
highlyCorDescr
length(highlyCorDescr)
unique(highlyCorDescr)
length(unique(highlyCorDescr))
dim(filteredDescr)
descrCor2 = cor(filteredDescr)
detach('package::dplyr')
detach('package:dplyr')
summary(descrCor2[upper.tri(descrCor2)])
apropos('find')
help(topic = 'find', package = 'caret')
help.search(pattern =  'find', package = 'caret')
ltfrDesign = matrix(0, nrow=6, ncol=6)
ltfrDesign[, 1] <- c(1, 1, 1, 1, 1, 1)
ltfrDesign[, 2] <- c(1, 1, 1, 0, 0, 0)
ltfrDesign[, 3] <- c(0, 0, 0, 1, 1, 1)
ltfrDesign[, 4] <- c(1, 0, 0, 1, 0, 0)
ltfrDesign[, 5] <- c(0, 1, 0, 0, 1, 0)
ltfrDesign[, 6] <- c(0, 0, 1, 0, 0, 1)
ltfrDesign
rowSums(ltfrDesign)
colSums(ltfrDesign)
comboInfo = findLinearCombos(ltfrDesign)
comboInfo
ltfrDesign[,-comboInfo$remove]
set.seed(96)
inTrain = sample(seq(along=mdrrClass), length(mdrrClass)/2)
head(mdrrClass)
training = filteredDescr[inTrain,]
test = filteredDescr[-inTrain,]
trainMDRR = mdrrClass[inTrain]
testMDRR = mdrrClass[-inTrain,]
preProcValues = preProcess(training, method = c('center','scale'))
testMDRR = mdrrClass[-inTrain]
class(preProcValues)
trainTransformed = predict(preProcValues, training)
testTransformed = preProcValues(preProcValues, test)
testTransformed = predict(preProcValues, test)
args(preProcess)
?preProcess
transparentTheme(trans = .4)
plotSubset = data.frame(scale(mdrrDescr[,c('nC','X4v')]))
xyplot(nc ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2))
xyplot(nC ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2))
library(doMC)
apropos('core')
apropos('core', ignore.case = T)
apropos('make', ignore.case = T)
find('cluster')
makeCluster(4)
help(package = 'doMC')
registerDoMC(4)
transformed = spatialSign(plotSubset)
transformed = as.data.frame(transformed)
head(transformed)
head(plotSubset)
find('spatialSign')
xyplot(nC ~ X4v,
data = transformed,
groups = mdrrClass,
auto.key = list(columns = 2))
preProcValues2 = preProcess(training, method = 'BoxCox')
trainBC = predict(preProcValues2, training)
testBC = predict(preProcValues2, test)
preProcValues2
dim(trainBC)
dim(training)
head(training)
training[1:5,1:3]
trainBC[1:5,1:3]
trainTransformed[1:5,1:3]
trainBC[1:5,1:3]
centrorids = classDist(trainBC, trainMDRR)
?classDist
distances = predict(centrorids, testBC)
head(centrorids)
names(centroids)
names(centrorids)
centrorids$values[1:6]
table(trainMDRR)
names(centrorids$values)
names(centrorids$classes)
class(centrorids$classes)
class(centrorids$values)
centrorids$values[[1]]
names(centrorids$values[[1]])
names(centrorids$values[[1]]$mean)
names(centrorids$values[[1]]$A)
centrorids$values[[1]]$A[1:5]
centrorids$values[[1]]$means[1:5]
?classDist
distances = predict(centrorids, testBC)
distances = as.data.frame(distances)
head(distances)
xyplot(dist.Active ~ dist.Inactive,
data = distances,
groups = testMDRR,
auto.key = list(columns = 2))
library(doMC)
registerDoMC(4)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3456)
set.seed(3456)
trainIndex = createDataPartition(iris$Species, p=.8,
list = FALSE,
times = 1)
head(trainIndex)
irisTrain = iris[trainIndex,]
irisTest = irise[-trainIndex,]
irisTrain = iris[trainIndex,]
irisTest = iris[-trainIndex,]
trainIndex3 = createDataPartition(iris$Species, p=.8,
list = FALSE,
times = 3)
head(trainIndex3)
tail(trainIndex3)
rm(trainIndex3)
library(mlbench)
data(BostonHousing)
testing = scale(BostonHousing[,c('age','nox')])
set.seed(11)
startSet = sample(1:dim(testing)[1],5)
samplePool = testing[-startSet,]
start = testing[startSet,]
newSamp = maxDissim(start, samplePool, n = 20)
head(newSamp)
nrow(newSamp)
length(newSamp)
?minDiss
example(sumDiss)
?do.call
minDiss
sapply(c(minDiss, sumDiss), function(obj) maxDissim(start, samplePool,
n = 20, obj = obj))
newSamp = sapply(c(minDiss, sumDiss), function(obj) maxDissim(start, samplePool,
n = 20, obj = obj))
?duplicated
?intersect
setdiff(newSamp[,1], newSamp[,2])
length(setdiff(newSamp[,1], newSamp[,2]))
